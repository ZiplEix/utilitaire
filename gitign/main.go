package gitign

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/ZiplEix/utilitaire/gitign/params"
	"github.com/gobwas/glob"
)

func isFolderIgnored(path string, ignore []string) bool {
	for _, pattern := range ignore {
		g := glob.MustCompile(pattern)
		if g.Match(path) {
			// println("Ignoring: ", path)
			return true
		}
	}
	return false
}

func header(gitignore *string) {
	*gitignore += "# Generated by gitign\n\n"

	*gitignore += "# Project Specific\n"
	*gitignore += "## You can add your own rules here\n"
	*gitignore += "\n"

	*gitignore += "# General\n"
	*gitignore += ".env\n"
	*gitignore += "*.log.*\n"
	*gitignore += ".docker/\n"
	*gitignore += ".tmp/\n"
	*gitignore += ".vscode/\n"
	*gitignore += "\n"
}

func downloadGitignore(url string) (string, error) {
	httpClient := http.Client{}

	resp, err := httpClient.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to fetch the URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %w", err)
	}

	return string(body), nil
}

func framedLanguageName(name string) string {
	line := strings.Repeat("#", len(name)+4)
	return fmt.Sprintf("%s\n# %s #\n%s\n", line, name, line)
}

func backupGitignore() error {
	_, err := os.Stat(".gitignore")
	if os.IsNotExist(err) {
		return nil
	}

	backupFile := ".gitignore.bak"
	err = os.Rename(".gitignore", backupFile)
	if err != nil {
		return fmt.Errorf("error while backing up .gitignore: %w", err)
	}
	fmt.Println("File .gitignore backed up as", backupFile)
	return nil
}

func openGitignoreFile(append bool) (*os.File, error) {
	if append {
		file, err := os.OpenFile(".gitignore", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			return nil, fmt.Errorf("Erreur d'ouverture du fichier en mode append: %w", err)
		}
		return file, nil
	}

	if err := backupGitignore(); err != nil {
		return nil, err
	}

	file, err := os.Create(".gitignore")
	if err != nil {
		return nil, fmt.Errorf("Erreur lors de la cr√©ation du fichier: %w", err)
	}

	return file, nil
}

func generateGitignore(languages []Langage, params params.Parameters) {
	file, err := openGitignoreFile(params.Append)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()

	gitignore := ""

	if !params.Append {
		header(&gitignore)
	}

	seenUrls := make(map[string]bool)

	for _, lang := range languages {
		if lang.NeedGitignore && !seenUrls[lang.Url] {
			gitignore += framedLanguageName(lang.Name)
			langageSpecificGitignore, err := downloadGitignore(lang.Url)
			if err != nil {
				fmt.Println(err)
			}

			gitignore += langageSpecificGitignore + "\n"
			seenUrls[lang.Url] = true
		}
	}

	if params.Optimize {
		err = optimizeGitignore(&gitignore)
		if err != nil {
			fmt.Println(err)
		}
	}

	// write to file
	_, err = file.WriteString(gitignore)
	if err != nil {
		fmt.Println(err)
	}
}

func DetectLanguages(params params.Parameters) {
	detectedLanguages := make(map[string]Langage)

	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// fmt.Println(path)
		if strings.Contains(path, ".git") && info.IsDir() {
			return filepath.SkipDir
		}

		if isFolderIgnored(path, params.Ignore) && info.IsDir() {
			return filepath.SkipDir
		}

		if !info.IsDir() {
			ext := strings.ToLower(filepath.Ext(path))

			if slices.Contains(params.Ignore, ext) {
				// println("==Ignoring: ", path)
				return nil
			}

			if lang, exists := langagesExtensions[ext]; exists {
				detectedLanguages[lang.Name] = lang
			}
		}

		return nil
	})

	if err != nil {
		fmt.Println(err)
	}

	var langages []Langage
	for _, lang := range detectedLanguages {
		langages = append(langages, lang)
	}

	generateGitignore(langages, params)
}

func GenerateGitignoreFromExtensions(extensions []string, params params.Parameters) {
	var langages []Langage
	for _, ext := range extensions {
		if lang, exists := langagesExtensions[ext]; exists {
			langages = append(langages, lang)
		}
	}

	generateGitignore(langages, params)
}

func OptimizeGitignore() {
	gitignore, err := os.ReadFile(".gitignore")
	if err != nil {
		fmt.Println(err)
		return
	}

	content := string(gitignore)

	err = optimizeGitignore(&content)
	if err != nil {
		fmt.Println(err)
	}

	err = os.WriteFile(".gitignore", []byte(content), 0644)
	if err != nil {
		fmt.Println(err)
	}
}
